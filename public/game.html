<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Boogaloo&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <title>Three.js - TubePainter et Interactions</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
        }
        #top-row {
            display: flex;
            flex-direction: row;
            align-items: center;
        }
        #ui button, #ui input[type="color"] {
            margin-bottom: 20px;
            font-size: 16px;
            cursor: pointer;
        }
        .button-container {
            position: relative;
            margin: 5px 0;
        }
        .action-button {
            --background-color: #005aff;
            --background-color-dark: #002d81;

            display: inline-block;
            margin: 0 8px;
            padding: 10px 16px;
            font-family: 'Boogaloo', cursive;
            font-size: 24px;
            text-transform: uppercase;
            color: #ffffff;
            text-decoration: none;
            border: none;
            outline: none;
            cursor: pointer;
            background-color: var(--background-color);
            box-shadow: 6px 6px 0 var(--background-color-dark);
            width: 150px;
            text-align: center;
        }

        .color {
            --background-color: #0045c6;
	        --background-color-dark: #002365;
        }

        .action-button:active {
            transform: translateX(2px) translateY(2px);
            box-shadow: 4px 4px 0 var(--background-color-dark);
        }

        .action-button--secondary {
            --background-color: #FF00DA;
            --background-color-dark: #840070;
        }

        .action-button--tertiary {
            --background-color: #19E633;
            --background-color-dark: #007d11;
        }

        .action-button[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            padding: 0;
            height: 40px;
            width: 40px;
            border-radius: 50%;
            overflow: hidden;
            cursor: pointer;
        }

        .action-button[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .action-button[type="color"]::-webkit-color-swatch {
            border: none;
        }

        .modal {
            display: none; /* Masquer par défaut */
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4); /* Fond semi-transparent */
        }

        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            padding-top: 1px;
            width: 80%;
            max-width: 500px;
            text-align: center;
            font-family: 'Boogaloo', cursive;
            border-radius: 10px/8px;
        }

        .modal-content p {
            font-size: 24px;
            margin-bottom: 20px;
        }

        .modal-content button {
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            background-color: #005aff;
            color: #ffffff;
            border: none;
            box-shadow: 4px 4px 0 #002d81;
            font-family: 'Boogaloo', cursive;
        }

        .modalText {
            margin-top: 10px;
        }

        /* Styles pour le bouton Home */
        .home-button {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--background-color);
            box-shadow: 6px 6px 0 var(--background-color-dark);
            border: none;
            cursor: pointer;
            color: #ffffff;
            font-size: 24px;
        }

        .home-button:active {
            transform: translateX(2px) translateY(2px);
            box-shadow: 4px 4px 0 var(--background-color-dark);
        }
    </style>
    <script>
        if (performance.navigation.type === performance.navigation.TYPE_RELOAD) {
            window.location.href = '../index.html';
        }
    </script>
</head>
<body>
    <!-- UI pour les boutons -->
    <div id="ui">
        <div id="top-row">
            <button id="toggleDrawMoveBtn" class="action-button button-container color">Draw mode</button>
            <input type="color" id="colorPicker" class="action-button button-container" value="#ff0000">
            <button id="undoBtn" class="action-button button-container" style="width: auto;">Undo</button>
            <button id="homeBtn" class="home-button action-button button-container" style="width: unset;"><i class="fas fa-home" style="height: 19.333px;"></i></button>
        </div>
        <button id="pageUpButton" class="action-button button-container">Next layer (1)</button>
        <button id="pageDownButton" class="action-button button-container">Previous Layer</button>
        <button id="toggleLayersBtn" class="action-button button-container">Hide layers</button>
    </div>

    <div id="modal" class="modal">
        <div class="modal-content">
            <p id="modalText">Discreetly look at the word to draw.</p>
            <button id="modalBtn" onclick="event.stopPropagation()">OK</button>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/controls/OrbitControls.js"></script>

    <script>
        const socket = io();
        const urlGameParams = new URLSearchParams(window.location.search);
        const room = urlGameParams.get('room');
        const playerId = urlGameParams.get('playerId');
        let playerRole = null;
        let isDrawer = false;

        function getRoomData(room) {
            return new Promise((resolve, reject) => {
            socket.emit('getRoomData', room);
            socket.on('roomData', (roomData) => {
                console.log(roomData);
                const player = roomData.players.find(p => p.id === playerId);
                if (player) {
                playerRole = player.role;
                isDrawer = playerRole === 'Drawer';
                resolve({ playerRole, isDrawer });
                } else {
                alert('Player not found in room. Redirecting to home page.');
                window.location.href = '../index.html';
                reject('Player not found');
                }
            });
            });
        }

        // Utiliser la promesse pour attendre les données de la salle
        getRoomData(room).then(({ playerRole, isDrawer }) => {
            if (!playerRole) {
                alert('Player not found in room. Redirecting to home page.');
                window.location.href = '../index.html';
            }

            // Étape 1 : Créer la scène, la caméra, et le rendu
            let scene = new THREE.Scene();
            let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            let renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            let isModalOpen = false;

            const urlParams = new URLSearchParams(window.location.search);
            const mode = urlParams.get('mode');

            if (mode === 'solo') {
                isModalOpen = true;
            }

            // Contrôles pour naviguer avec la souris
            let controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enablePan = false;
            controls.enableRotate = true;  // Désactiver la rotation par défaut
            controls.enableZoom = true;
            controls.mouseButtons = {
                LEFT: THREE.MOUSE.PAN,    // Utiliser le clic gauche pour le panoramique
                MIDDLE: THREE.MOUSE.DOLLY, // Utiliser la molette de la souris pour le zoom
                RIGHT: THREE.MOUSE.ROTATE  // Utiliser le clic droit pour la rotation
            };
            camera.position.set(0, 60, 100);
            controls.update();

            // Empêcher le menu contextuel par défaut sur le clic droit
            window.addEventListener('contextmenu', (event) => {
                event.preventDefault();
            });

            let displayPlans = true; 
            let planes = [];
            let spheres = [];  // Tableau pour stocker les sphères
            let currentPlane = 0;  // Variable pour suivre le plan actuel
            const geometry = new THREE.PlaneGeometry(100, 100);  // Taille des plans
            const distanceBetweenPlanes = 1;  // Distance entre chaque plan

            material = new THREE.MeshBasicMaterial({
                        color: 0x87CEEB,  // Couleur bleue
                        side: THREE.DoubleSide,
                        transparent: true,  // Activation de la transparence
                        opacity: 0.9  // Opacité élevée pour le premier plan
                    });
            const plane = new THREE.Mesh(geometry, material);
            plane.position.y = currentPlane * distanceBetweenPlanes;
            plane.rotation.x = Math.PI / 2; // Orienter le plan horizontalement
            scene.add(plane);
            planes.push(plane);

            function addPlane() {
                const material = new THREE.MeshBasicMaterial({
                    color: 0x87CEEB,  // Couleur bleue
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.15
                });
                const plane = new THREE.Mesh(geometry, material);
                plane.position.y = (currentPlane + 1) * distanceBetweenPlanes;
                plane.rotation.x = Math.PI / 2; // Orienter le plan horizontalement
                scene.add(plane);
                planes.push(plane);
            }
            
            let currentColor = '#ff0000';
            // let colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xffffff, 0x000000, 0xffa500, 0x800080];  // Couleurs pour les sphères

            // Lumières
            let ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            let directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // Variable pour suivre si on dessine
            let isDrawing = false;
            let lastDrawPosition = null; // Dernière position de dessin pour garantir un trait continu
            const minDistance = 1; // Distance minimale entre deux sphères pour le trait continu

            let traces = [];  // Tableau pour stocker les traces
            let currentTrace = [];  // Trace actuelle

            // Fonction pour ajouter une sphère
            function addSphere(position, color) {
                let sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
                let sphereMaterial = new THREE.MeshStandardMaterial({ color: color });
                let sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.copy(position);
                scene.add(sphere);
                spheres.push(sphere);  // Ajout de la sphère au tableau des sphères
                currentTrace.push(sphere);  // Ajout de la sphère au tableau de la trace actuelle
            }

            // Gestion des événements pour placer des sphères, peindre, ou se déplacer

            function drawSphereContinuously(event) {
                if (!isDrawing) return;

                let mouse = new THREE.Vector2();
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                let raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);

                let intersects = raycaster.intersectObject(planes[currentPlane]);
                if (intersects.length > 0) {
                    let intersectPoint = intersects[0].point;

                    if (!lastDrawPosition || lastDrawPosition.distanceTo(intersectPoint) > minDistance) {
                        addSphere(intersectPoint, currentColor);
                        lastDrawPosition = intersectPoint.clone(); // Mise à jour de la dernière position
                    }
                }
            }

            // Variable pour suivre si les contrôles sont activés
            let controlsEnabled = false;

            window.addEventListener('mousedown', (event) => {
                if (event.target.closest('#ui'))
                    return;

                if (isModalOpen) {
                    isModalOpen = false;
                    return;
                }

                if (!controlsEnabled)
                {
                    if (event.button === 0) {
                        // let mouse = new THREE.Vector2();
                        // mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                        // mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                        // let raycaster = new THREE.Raycaster();
                        // raycaster.setFromCamera(mouse, camera);

                        // let intersects = raycaster.intersectObject(planes[currentPlane]);
                        // if (intersects.length > 0) {
                        //     let intersectPoint = intersects[0].point;
                        //     addSphere(intersectPoint, currentColor);
                        // }
                        isDrawing = true;
                        drawSphereContinuously(event);
                    }
                }
            });

            window.addEventListener('mousemove', (event) => {
                drawSphereContinuously(event);  // Dessiner en continu pendant le déplacement
            });

            window.addEventListener('mouseup', (event) => {
                isDrawing = false;
                lastDrawPosition = null; // Réinitialiser la dernière position
                if (event.button === 0 && currentTrace.length > 0) {  // 0 correspond au clic gauche
                    traces.push(currentTrace);
                    currentTrace = [];
                }
            });

            // Fonction d'animation
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
                
                if (displayPlans) {
                    // Mettre à jour la visibilité des plans et des sphères
                    planes.forEach((plane, index) => {
                        plane.visible = index <= currentPlane;  // Rendre le plan visible seulement s'il est <= currentPlane
                    });
                }
                else {
                    planes.forEach(plane => {
                        plane.visible = false;  // Cacher tous les plans
                    });
                }

                spheres.forEach(sphere => {
                    const planeIndex = Math.floor((sphere.position.y + 0.3) / distanceBetweenPlanes);
                    sphere.visible = planeIndex <= currentPlane; 
                });

                if (controlsEnabled) {
                    controls.enablePan = true;
                }
                else {
                    controls.enablePan = false;
                }
            }
            animate();

            function updateNextLayerButton() {
                const nextLayerButton = document.getElementById('pageUpButton');
                nextLayerButton.textContent = `Next layer (${currentPlane + 1})`;
            }

            // Mettre à jour le rendu en cas de redimensionnement de la fenêtre
            window.addEventListener('resize', () => {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            });

            document.getElementById('toggleDrawMoveBtn').addEventListener('click', (e) => {
                const button = e.target;

                if (button.textContent === 'Draw mode') {
                    button.textContent = 'Move mode';
                    // Activer les contrôles de mouvement
                    controlsEnabled = true;
                } else {
                    button.textContent = 'Draw mode';
                    // Désactiver les contrôles de mouvement
                    controlsEnabled = false;
                }
            });

            document.getElementById('toggleLayersBtn').addEventListener('click', (e) => {
                const button = e.target;
                if (button.textContent === 'Hide layers') {
                    button.textContent = 'Show layers';
                    displayPlans = false;
                } else {
                    button.textContent = 'Hide layers';
                    displayPlans = true;
                }
            });

            document.getElementById('colorPicker').addEventListener('input', (e) => {
                currentColor = e.target.value;
            });

            document.getElementById('pageUpButton').addEventListener('click', () => {
                if (currentPlane >= planes.length - 1) {
                    addPlane();
                }
                currentPlane++;
                updateNextLayerButton();
            });

            document.getElementById('pageDownButton').addEventListener('click', () => {
                if (currentPlane > 0) {
                    currentPlane--;
                }
                updateNextLayerButton();
            });

            document.getElementById('undoBtn').addEventListener('click', () => {
                if (traces.length > 0) {
                    const lastTrace = traces.pop();
                    lastTrace.forEach(sphere => {
                        scene.remove(sphere);
                        spheres = spheres.filter(s => s !== sphere);
                    });
                }
            });

            // Logique pour le multijoueur
            if (!isDrawer) {
                document.getElementById('toggleDrawMoveBtn').style.display = 'none';
                document.getElementById('colorPicker').style.display = 'none';
                document.getElementById('undoBtn').style.display = 'none';
                document.getElementById('pageUpButton').style.display = 'none';
                document.getElementById('pageDownButton').style.display = 'none';
                document.getElementById('toggleLayersBtn').style.display = 'none';
            }

            const bodyParts = ["head", "arm", "leg", "hand", "foot", "eye", "ear", "nose", "mouth", "finger"];

            // Fonction pour afficher la fenêtre modale avec un mot aléatoire
            function showModal() {
                const modal = document.getElementById('modal');
                const modalText = document.getElementById('modalText');
                const randomWord = bodyParts[Math.floor(Math.random() * bodyParts.length)];
                modalText.textContent = `Secretly look at the word to draw: ${randomWord}`;
                modal.style.display = 'block';

                const modalBtn = document.getElementById('modalBtn');
                modalBtn.onclick = function() {
                    modal.style.display = 'none';
                    // L'utilisateur peut maintenant commencer à dessiner
                };
            }

            if (mode === 'solo' || isDrawer) {
                showModal();
            }

            if (isDrawer) {
                document.getElementById('toggleDrawMoveBtn').addEventListener('click', () => {
                    // Logique pour dessiner
                    const position = new THREE.Vector3(Math.random() * 10, Math.random() * 10, Math.random() * 10);
                    const color = document.getElementById('colorPicker').value;
                    addSphere(position, color);
                    socket.emit('draw', { position, color });
                    });
            }

            socket.on('draw', ({ position, color }) => {
                addSphere(new THREE.Vector3(position.x, position.y, position.z), color);
            });

            document.getElementById('homeBtn').addEventListener('click', () => {
                window.location.href = '../index.html'; // Rediriger vers la page d'accueil
            });

            // Désactiver le menu contextuel par défaut (clic droit)
            window.addEventListener('contextmenu', (event) => {
                event.preventDefault();
            });
        });
    </script>
</body>
</html>